{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to qtstrap's documentation Features qtstrap command line tool to bootstrap new projects crossplatform makefile with useful development commands preconfigured pyinstaller spec file preconfigured InnoSetup setup compiler script custom Qt widgets with useful behaviors Pythonic layout system using ContextLayouts Some other stuff I haven't remembered yet","title":"Home"},{"location":"#welcome-to-qtstraps-documentation","text":"","title":"Welcome to qtstrap's documentation"},{"location":"#features","text":"qtstrap command line tool to bootstrap new projects crossplatform makefile with useful development commands preconfigured pyinstaller spec file preconfigured InnoSetup setup compiler script custom Qt widgets with useful behaviors Pythonic layout system using ContextLayouts Some other stuff I haven't remembered yet","title":"Features"},{"location":"quickstart/baseapplication/","text":"BaseApplication BaseApplication is a subclass of QApplication , adding several behaviors that address shortcomings of the Qt/PySide2/PyQt environment. Ctrl+C Handler Due to the way that the thin layer of python interacts with the Qt libraries underneath, a naked PySide2/PyQt application can't be stopped using ctrl+c like a normal program. I find this extremely annoying. The solution to this has two parts. Part 1 is to use the python signal library to bind a function to the SIGINT signal. Unfortunately, this isn't enough, because in order for signal handler to fire, the python interpreter needs to get some cpu time. Once you start the Qt interpreter using app.exec_() , execution passes down into Qt's C++ code and doesn't return until the application exits. Thus, we need to artifically secure some runtime for the python interpreter. This is part 2: creating a QTimer that triggers every 10ms(the exact time is not important) and calls an empty python function, update() . When the timer triggers and update() is called, execution is passed back to the python interpreter, giving it a chance to process signals. def init_ctrlc_handler(self): # grab the keyboard interrupt signal signal.signal(signal.SIGINT, self.ctrlc_handler) # empty timer callback def update(): pass # create timer to force python interpreter to get some runtime self.timer = QTimer() # create a QTimer self.timer.timeout.connect(update) # connect to our empty timer callback self.timer.start(10) # set the timer to trigger every 10mS App Info Several Qt modules can automatically query the running QApplication for a number of attributes: organizationName organizationDomain applicationName applicationVersion One example is QSettings , which \"provides persistent, platform-independent application settings\". Using QSettings reqires an applicationName and an organizationName. # every time you want to access QSettings, yuck settings = QSettings('Organization', 'Application') However, if you give this information to your QApplication , then QSettings will use those values so you don't have to specify them every time. # once, at startup app = QApplication() app.setOrganizationName('Organization') app.setApplicationName('Application') # every time you want to access QSettings, much better! settings = QSettings() As a side bonus, a QMainWindow will automatically set its window title attribute to the QApplication 's applicationName .","title":"BaseApplication"},{"location":"quickstart/baseapplication/#baseapplication","text":"BaseApplication is a subclass of QApplication , adding several behaviors that address shortcomings of the Qt/PySide2/PyQt environment.","title":"BaseApplication"},{"location":"quickstart/baseapplication/#ctrlc-handler","text":"Due to the way that the thin layer of python interacts with the Qt libraries underneath, a naked PySide2/PyQt application can't be stopped using ctrl+c like a normal program. I find this extremely annoying. The solution to this has two parts. Part 1 is to use the python signal library to bind a function to the SIGINT signal. Unfortunately, this isn't enough, because in order for signal handler to fire, the python interpreter needs to get some cpu time. Once you start the Qt interpreter using app.exec_() , execution passes down into Qt's C++ code and doesn't return until the application exits. Thus, we need to artifically secure some runtime for the python interpreter. This is part 2: creating a QTimer that triggers every 10ms(the exact time is not important) and calls an empty python function, update() . When the timer triggers and update() is called, execution is passed back to the python interpreter, giving it a chance to process signals. def init_ctrlc_handler(self): # grab the keyboard interrupt signal signal.signal(signal.SIGINT, self.ctrlc_handler) # empty timer callback def update(): pass # create timer to force python interpreter to get some runtime self.timer = QTimer() # create a QTimer self.timer.timeout.connect(update) # connect to our empty timer callback self.timer.start(10) # set the timer to trigger every 10mS","title":"Ctrl+C Handler"},{"location":"quickstart/baseapplication/#app-info","text":"Several Qt modules can automatically query the running QApplication for a number of attributes: organizationName organizationDomain applicationName applicationVersion One example is QSettings , which \"provides persistent, platform-independent application settings\". Using QSettings reqires an applicationName and an organizationName. # every time you want to access QSettings, yuck settings = QSettings('Organization', 'Application') However, if you give this information to your QApplication , then QSettings will use those values so you don't have to specify them every time. # once, at startup app = QApplication() app.setOrganizationName('Organization') app.setApplicationName('Application') # every time you want to access QSettings, much better! settings = QSettings() As a side bonus, a QMainWindow will automatically set its window title attribute to the QApplication 's applicationName .","title":"App Info"},{"location":"quickstart/basemainwindow/","text":"BaseMainWindow BaseMainWindow is a subclass of QMainWindow , adding several behaviors that address shortcomings of the Qt/PySide2/PyQt environment. Window Icon The BaseMainWindow will look for an icon file at resources/application.ico and automatically set it as the window icon, if it finds it. This icon is also used when packaging your application for distribution. qtstrap ships with a default icon you can use until you create your own. Window Settings A BaseMainWindow will stay where you put it, even when you close and and reopen your app. BaseMainWindow has a pair of methods, .save_settings() and .load_settings() , that will save and restore the window's geometry(it's size and position) and it's state(minimized/maximized, etc). .load_settings() is automatically called when starting the application, and .save_settings() is automatically called when closing it.","title":"BaseMainWindow"},{"location":"quickstart/basemainwindow/#basemainwindow","text":"BaseMainWindow is a subclass of QMainWindow , adding several behaviors that address shortcomings of the Qt/PySide2/PyQt environment.","title":"BaseMainWindow"},{"location":"quickstart/basemainwindow/#window-icon","text":"The BaseMainWindow will look for an icon file at resources/application.ico and automatically set it as the window icon, if it finds it. This icon is also used when packaging your application for distribution. qtstrap ships with a default icon you can use until you create your own.","title":"Window Icon"},{"location":"quickstart/basemainwindow/#window-settings","text":"A BaseMainWindow will stay where you put it, even when you close and and reopen your app. BaseMainWindow has a pair of methods, .save_settings() and .load_settings() , that will save and restore the window's geometry(it's size and position) and it's state(minimized/maximized, etc). .load_settings() is automatically called when starting the application, and .save_settings() is automatically called when closing it.","title":"Window Settings"},{"location":"quickstart/gettingstarted/","text":"Getting Started After installing qtstrap and creating a new project using qtstrap init , the first thing you should do is familiarize yourself with the qtstrap project structure . This will create a project skeleton in your current directory. main.py from application import Application def run(): app = Application() # Create the Qt Application app.exec_() # Run the main Qt loop if __name__ == \"__main__\": run() main.py is the entry point into your application. It contains the function run() which creates an instance of Application and starts the Qt event loop with .exec_() . If you want to do anything before starting Qt, it belongs here in run() . Examples could be installing custom logging handlers or checking for updates. application.py from qtstrap import * from main_window import MainWindow class Application(BaseApplication): def __init__(self) -> None: super().__init__() self.window = MainWindow() # create window self.window.show() # open it application.py is where your customized QApplication lives. Here, we create an instance of MainWindow and open it. Any kind of long running or singleton modules or subsystems can be initialized here, where they'll live for the lifetime of the QApplication. BaseApplication has several useful behaviors that can read about here . main_window.py from qtstrap import * class MainWindow(BaseMainWindow): def __init__(self): super().__init__() set_font_options(self, {'setPointSize': 12}) self.setMinimumSize(400, 300) self.label = QLabel('Hello World!') self.button = QPushButton('Click me!', clicked=self.on_click) with CVBoxLayout(self) as layout: with layout.hbox(align='center') as layout: layout.add(self.label) layout.add(self.button) self.label.setVisible(False) def on_click(self): self.button.setVisible(False) self.label.setVisible(True) main_window.py is where your application's MainWindow is defined.","title":"Getting Started"},{"location":"quickstart/gettingstarted/#getting-started","text":"After installing qtstrap and creating a new project using qtstrap init , the first thing you should do is familiarize yourself with the qtstrap project structure . This will create a project skeleton in your current directory.","title":"Getting Started"},{"location":"quickstart/gettingstarted/#mainpy","text":"from application import Application def run(): app = Application() # Create the Qt Application app.exec_() # Run the main Qt loop if __name__ == \"__main__\": run() main.py is the entry point into your application. It contains the function run() which creates an instance of Application and starts the Qt event loop with .exec_() . If you want to do anything before starting Qt, it belongs here in run() . Examples could be installing custom logging handlers or checking for updates.","title":"main.py"},{"location":"quickstart/gettingstarted/#applicationpy","text":"from qtstrap import * from main_window import MainWindow class Application(BaseApplication): def __init__(self) -> None: super().__init__() self.window = MainWindow() # create window self.window.show() # open it application.py is where your customized QApplication lives. Here, we create an instance of MainWindow and open it. Any kind of long running or singleton modules or subsystems can be initialized here, where they'll live for the lifetime of the QApplication. BaseApplication has several useful behaviors that can read about here .","title":"application.py"},{"location":"quickstart/gettingstarted/#main_windowpy","text":"from qtstrap import * class MainWindow(BaseMainWindow): def __init__(self): super().__init__() set_font_options(self, {'setPointSize': 12}) self.setMinimumSize(400, 300) self.label = QLabel('Hello World!') self.button = QPushButton('Click me!', clicked=self.on_click) with CVBoxLayout(self) as layout: with layout.hbox(align='center') as layout: layout.add(self.label) layout.add(self.button) self.label.setVisible(False) def on_click(self): self.button.setVisible(False) self.label.setVisible(True) main_window.py is where your application's MainWindow is defined.","title":"main_window.py"},{"location":"quickstart/installation/","text":"Installation Existing Projects: Adding qtstrap to an existing project is easy python3 -m pip install qtstrap New Projects: This is the recommended way to create a new project using qtstrap: $ mkdir test && cd test $ python3 -m venv .venv $ source .venv/bin/activate $ python3 -m pip install qtstrap PySide2 $ qtstrap init The init script will prompt you to enter the name of your application and the name of its publisher(which is probably you), and then it will generate an application skeleton. At this point you can deactivate the virtual environment and forget it exists(until you need to add a package or something). You can test that everything installed properly by executing: $ make run If you see a window like this, then you're good to go:","title":"Installation"},{"location":"quickstart/installation/#installation","text":"","title":"Installation"},{"location":"quickstart/installation/#existing-projects","text":"Adding qtstrap to an existing project is easy python3 -m pip install qtstrap","title":"Existing Projects:"},{"location":"quickstart/installation/#new-projects","text":"This is the recommended way to create a new project using qtstrap: $ mkdir test && cd test $ python3 -m venv .venv $ source .venv/bin/activate $ python3 -m pip install qtstrap PySide2 $ qtstrap init The init script will prompt you to enter the name of your application and the name of its publisher(which is probably you), and then it will generate an application skeleton. At this point you can deactivate the virtual environment and forget it exists(until you need to add a package or something). You can test that everything installed properly by executing: $ make run If you see a window like this, then you're good to go:","title":"New Projects:"},{"location":"reference/context_layouts/context_layouts/","text":"","title":"Context layouts"},{"location":"reference/utils/timestamp/","text":"","title":"Timestamp"},{"location":"reference/widgets/baseapplication/","text":"BaseApplication","title":"BaseApplication"},{"location":"reference/widgets/baseapplication/#baseapplication","text":"","title":"BaseApplication"},{"location":"reference/widgets/basemainwindow/","text":"","title":"Basemainwindow"},{"location":"structure/makefile/","text":"Makefile The provided Makefile has several targets that assist with general project development. Using the Makefile means that you do not have to activate the venv unless you need to interact with it directly. The Makefile uses specially constructed targets to automatically build the venv and execute using the venv's python installation. General targets: make run run your project make debug run your project in debug mode make bundle builds a single-folder bundle using PyInstaller make run_bundle run the single-folder bundle's executable make zip compress the bundle into a zip file make installer wrap the bundle into a Windows installer using Inno Setup make clean delete the project's build artifacts The Makefile also seamlessly manages your python virtual environment using the following targets: make venv create the venv, if it doesn't exist make pip passes it's args to the venv's pip make clean_venv deletes the venv make reset_venv deletes the venv and then rebuilds it Virtual Environment Management TODO: a brief intro to Makefiles, and then an explanation of how this Makefile manages the venv","title":"Makefile"},{"location":"structure/makefile/#makefile","text":"The provided Makefile has several targets that assist with general project development. Using the Makefile means that you do not have to activate the venv unless you need to interact with it directly. The Makefile uses specially constructed targets to automatically build the venv and execute using the venv's python installation. General targets: make run run your project make debug run your project in debug mode make bundle builds a single-folder bundle using PyInstaller make run_bundle run the single-folder bundle's executable make zip compress the bundle into a zip file make installer wrap the bundle into a Windows installer using Inno Setup make clean delete the project's build artifacts The Makefile also seamlessly manages your python virtual environment using the following targets: make venv create the venv, if it doesn't exist make pip passes it's args to the venv's pip make clean_venv deletes the venv make reset_venv deletes the venv and then rebuilds it","title":"Makefile"},{"location":"structure/makefile/#virtual-environment-management","text":"TODO: a brief intro to Makefiles, and then an explanation of how this Makefile manages the venv","title":"Virtual Environment Management"},{"location":"structure/structure/","text":"Project Structure This is the project structure that's created by running qtstrap init : |-- src | |-- main.py | |-- application.py | |-- mainwindow.py |-- resources | |-- application.ico | |-- icon.svg |-- bundle.spec |-- installer.iss |-- Makefile |-- project.ini |-- requirements.txt Files src folder Your application's python source code should all be placed here. A newly created qtstrap project contains src/main.py , src/application.py , and src/main_window.py . Makefile The provided Makefile has several targets that assist with general project development. Using the Makefile means that you do not have to activate the venv unless you need to interact with it directly. The Makefile uses specially constructed targets to automatically build the venv and execute using the venv's python installation. Most of the time you'll just use make run to start your application. When you're ready to package up your app for distribution, you'll want to use make bundle , make zip , and (on Windows) make installer . More information about the Makefile and it's targets can found here project.ini Contains information about the project like the Application Name and Publisher. This file is referenced by bundle.spec and installer.iss , and used to feed information to PyInstaller and InnoSetup. The project file defines the following fields: AppName your app's name AppVersion your app's version number AppPublisher your app's publisher, which is most likely you AppExeName the name of the executable created by make bundle AppIconName the path to your application's icon AppId a GUID used by Inno Setup to uniquely identify your app resources/application.ico and icon.svg Icon files that are automatically applied to the app's titlebar, taskbar entry, bundle, and installer. When running the bundled executable, the installer, or the installed version of your app, the icon should also appear in Windows Task Manager. requirements.txt Your application's python dependecies. If your application uses any packages, you should list them here, preferably with the versions pinned. A fresh project created with qtstrap init looks something like this: altgraph==0.17 click==7.1.2 future==0.18.2 pefile==2019.4.18 prompt-toolkit==1.0.14 Pygments==2.8.1 PyInquirer==1.0.3 pyinstaller==4.2 pyinstaller-hooks-contrib==2021.1 PySide2==5.15.2 pywin32-ctypes==0.2.0 qtstrap==0.0.7 regex==2021.3.17 shiboken2==5.15.2 six==1.15.0 wcwidth==0.2.5 bundle.spec A PyInstaller spec file that creates a single-folder executable. The bundle is created at ./dist/$AppName/ , and the executable at ./dist/$AppName/$AppName.exe . installer.iss An Inno Setup setup compiler script that creates a Windows installer. The installer is created at /dist/installer/$AppName-$AppVersion-Setup.exe","title":"Project Structure"},{"location":"structure/structure/#project-structure","text":"This is the project structure that's created by running qtstrap init : |-- src | |-- main.py | |-- application.py | |-- mainwindow.py |-- resources | |-- application.ico | |-- icon.svg |-- bundle.spec |-- installer.iss |-- Makefile |-- project.ini |-- requirements.txt","title":"Project Structure"},{"location":"structure/structure/#files","text":"","title":"Files"},{"location":"structure/structure/#src-folder","text":"Your application's python source code should all be placed here. A newly created qtstrap project contains src/main.py , src/application.py , and src/main_window.py .","title":"src folder"},{"location":"structure/structure/#makefile","text":"The provided Makefile has several targets that assist with general project development. Using the Makefile means that you do not have to activate the venv unless you need to interact with it directly. The Makefile uses specially constructed targets to automatically build the venv and execute using the venv's python installation. Most of the time you'll just use make run to start your application. When you're ready to package up your app for distribution, you'll want to use make bundle , make zip , and (on Windows) make installer . More information about the Makefile and it's targets can found here","title":"Makefile"},{"location":"structure/structure/#projectini","text":"Contains information about the project like the Application Name and Publisher. This file is referenced by bundle.spec and installer.iss , and used to feed information to PyInstaller and InnoSetup. The project file defines the following fields: AppName your app's name AppVersion your app's version number AppPublisher your app's publisher, which is most likely you AppExeName the name of the executable created by make bundle AppIconName the path to your application's icon AppId a GUID used by Inno Setup to uniquely identify your app","title":"project.ini"},{"location":"structure/structure/#resourcesapplicationico-and-iconsvg","text":"Icon files that are automatically applied to the app's titlebar, taskbar entry, bundle, and installer. When running the bundled executable, the installer, or the installed version of your app, the icon should also appear in Windows Task Manager.","title":"resources/application.ico and icon.svg"},{"location":"structure/structure/#requirementstxt","text":"Your application's python dependecies. If your application uses any packages, you should list them here, preferably with the versions pinned. A fresh project created with qtstrap init looks something like this: altgraph==0.17 click==7.1.2 future==0.18.2 pefile==2019.4.18 prompt-toolkit==1.0.14 Pygments==2.8.1 PyInquirer==1.0.3 pyinstaller==4.2 pyinstaller-hooks-contrib==2021.1 PySide2==5.15.2 pywin32-ctypes==0.2.0 qtstrap==0.0.7 regex==2021.3.17 shiboken2==5.15.2 six==1.15.0 wcwidth==0.2.5","title":"requirements.txt"},{"location":"structure/structure/#bundlespec","text":"A PyInstaller spec file that creates a single-folder executable. The bundle is created at ./dist/$AppName/ , and the executable at ./dist/$AppName/$AppName.exe .","title":"bundle.spec"},{"location":"structure/structure/#installeriss","text":"An Inno Setup setup compiler script that creates a Windows installer. The installer is created at /dist/installer/$AppName-$AppVersion-Setup.exe","title":"installer.iss"}]}